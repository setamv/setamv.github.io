[Back](index.md)

# Presenting Data

# Profile
- Book: Linux Command Line and Shell Scripting Bible
- Chapter: Chapter 12: Presenting Data
- Pages: {, }
- Reading Time: 06/04/2017 21:15

# Content Navigation <a id="≡"></a>
- [Understanding Input and Output](#CLP)
  + [Standard file descriptors](#UIAO-SFD)
    * [STDIN](#UIAO-SFD-STDIN)
    * [STDOUT](#UIAO-SFD-STDOUT)
    * [STDERR](#UIAO-SFD-STDERR)
  + [Redirecting errors](#UIAO-RE)
    * [Redirecting just errors](#UIAO-RE-RJE)
    * [Redirecting errors and data](#UIAO-RE-READ)
- [Redirecting Output in Scripts](#ROIS)
  + [Temporary redirections](#ROIS-TR)
  + [Permanent redirections](#ROIS-PR)
- [Redirecting Input in Scripts](#RIIS)
- [Creating Your Own Redirection](#CYOD)
  + [Creating output file descriptors](#CYOR-COFD)
  + [Redirecting file descriptors](#CYOR-RFD)
  + [Creating input file descriptors](#CYOR-CIFD)
  + [Creating a read/write file descriptor](#CYOR-CARWFD)
  + [Closing file descriptors](#CYOR-CFD)
- [Listing Open File Descriptors](#LOFD)

# Reading Notes

## Understanding Input and Output <a id="UIAO">[≡](#≡)</a>

### Standard file descriptors <a id="UIAO-SFD">[≡](#≡)</a>

The Linux system handles every object as a file. This includes the input and output process. Linux identifies each file object using a file descriptor. The file descriptor is a non-negative integer, which uniquely identifies open files in a session. Each process is allowed to have up to nine open file descriptors at a time. The bash shell reserves the first three file descriptors (0, 1, and 2) for special purposes. These are shown in the following table:    

| **File Descriptor** | **Abbreviation** |  Description**  |
|---------------------|------------------|-----------------|
|                   0 | STDIN            | Standard Input  |
|                   1 | STDOUT           | Standard Output |
|                   2 | STDERR           | Standard Error  |

These three special file descriptors handle the input and output from your script. The shell uses them to direct the default input and output in the shell to the appropriate location (which by default is usually your monitor).    


#### STDIN <a id="UIAO-SFD-STDIN">[≡](#≡)</a>

The `STDIN` file descriptor references the standard input to the shell. For a terminal interface, the standard input is the keyboard. The shell receives input from the  keyboard on the STDIN file descriptor, and processes each character as you type it.

When you use the input redirect symbol (<), Linux replaces the standard input file descriptor with the file referenced by the redirection. It reads the file and retrieves data just as if it were typed on the keyboard。

Many bash commands accept input from STDIN, especially if no files are specified on the command line. Here’s an example of using the `cat` command with data entered from STDIN: 
```
$ cat
this is a test
this is a test
```
When you enter the cat command on the command line by itself, it accepts input from STDIN. As you enter each line, the cat command echoes the line to the display.

However, you can also use the STDIN redirect symbol to force the cat command to accept input from another file other than STDIN:    
```
$ cat < data
setamv
susie
angel
anhong is the son of setamv and susie.
```

Now the `cat` command uses the lines that are contained in the testfile file as the input. You can use this technique to input data to any shell command that accepts data from STDIN.


#### STDOUT <a id="UIAO-SFD-STDOUT">[≡](#≡)</a>

The STDOUT file descriptor references the standard output for the shell. On a terminal interface, the standard output is the terminal monitor. All output from the shell (including programs and scripts you run in the shell) is directed to the standard output, which is the monitor.


#### STDERR <a id="UIAO-SFD-STDERR">[≡](#≡)</a>

The shell handles error messages using the special STDERR file descriptor. The STDERR file descriptor references the standard error output for the shell. This is the location where the shell sends error messages generated by the shell or programs and scripts running in the shell.

By default, the STDERR file descriptor points to the same place as the STDOUT file descriptor (even though they are assigned different file descriptor values). This means that, by default, all error messages go to the monitor display.

### Redirecting errors <a id="UIAO-RE">[≡](#≡)</a>

You’ve already seen how to redirect the STDOUT data by using the redirection symbol. Redirecting the STDERR data isn’t much different, you just need to define the STDERR file descriptor when you use the redirection symbol. There are a couple of ways to do this.

#### Redirecting just errors <a id="UIAO-RE-RJE">[≡](#≡)</a>

The STDERR file descriptor is set to the value 2. You can select to redirect
only error messages by placing this file descriptor value immediately before the redirection symbol. The value must appear immediately before the redirection symbol or it won’t work (the _badfile_ bellow is not exists):    
```
$ ls -al badfile 2> test4
$ cat test4
ls: cannot access badfile: No such file or directory
```

Now when you run the command, the error message doesn’t appear on the monitor. Instead,  the output file contains any error messages that are generated by the command. Using this method, the shell only redirects the error messages, not the normal data.

#### Redirecting errors and data <a id="UIAO-RE-READ">[≡](#≡)</a>

If you want to redirect both errors and the normal output, you’ll need to use two redirection symbols. You need to precede each with the appropriate file descriptor for the data you want to redirect, then have them point to the appropriate output file for holding the data:   
```
$ ls -al test test2 test3 badtest 2> test6 1> test7
$ cat test6
ls: cannot access test: No such file or directory
ls: cannot access badtest: No such file or directory
$ cat test7
-rw-rw-r-- 1 rich rich 158 2007-10-26 11:32 test2
-rw-rw-r-- 1 rich rich 0 2007-10-26 11:33 test3
```
The shell redirects the normal output of the `ls` command that would have gone to STDOUT to the test7 file using the `1>` symbol. Any error messages that would have gone to STDERR were redirected to the test6 file using the `2>` symbol.

You can use this technique to separate normal script output from any error messages that occur in the script.  

Alternatively, if you want, you can redirect both STDERR and STDOUT output to the same output file. The bash shell provides a special redirection symbol just for this purpose, the `&>` symbol:       
```
$ ls -al test test2 test3 badtest &> test7
$ cat test7
ls: cannot access test: No such file or directory
ls: cannot access badtest: No such file or directory
-rw-rw-r-- 1 rich rich 158 2007-10-26 11:32 test2
-rw-rw-r-- 1 rich rich 0 2007-10-26 11:33 test3
```
Using the &> symbol, all of the output generated by the command is sent to the same location, both data and errors. You’ll notice that one of the error messages is out of order from what you’d expect. The error message for the badtest file (the last file to be listed) appears second in the output file. The bash shell automatically gives error messages a higher priority than the standard output. This allows you to view the error messages together, rather than scattered throughout the output file.


## Redirecting Output in Scripts <a id="ROIS">[≡](#≡)</a>

You can use the STDOUT and STDERR file descriptors in your scripts to produce output in
multiple locations simply by redirecting the appropriate file descriptors. There are two methods for redirecting output in the script:

1. Temporarily redirecting each line
2. Permanently redirecting all commands in the script


### Temporary redirections <a id="ROIS-TR">[≡](#≡)</a>

If you want to purposely generate error messages in your script, you can redirect an individual output line to STDERR. All you need to do is use the output redirection symbol to redirect the output to the STDERR file descriptor. When you redirect to a file descriptor, you must precede the file descriptor number with an ampersand sign (&):    
`echo "This is an error message" >&2`

This line displays the text wherever the STDERR file descriptor for the script is pointing, instead of the normal STDOUT. Here’s an example of a script that uses this feature:    
```
#!/bin/bash

$ cat stderr.sh 
#!/bin/bash
echo "This is a manually created error output." >&2
echo "This is a normal output."
```

If you run the script as normal, you won’t notice any difference as by default Linux directs the STDERR output to STDOUT:        
```
$ ./stderr.sh 
This is a manually created error output.
This is a normal output.
```

However, if you redirect STDERR when running the script, any text directed to STDERR in the script will be redirected:    
```
$ ./stderr.sh 2> error.log
This is a normal output.

$ cat error.log
This is a manually created error output.
```

Perfect! The text that’s displayed using STDOUT appears on the monitor, while the echo statement text sent to STDERR is redirected to the output file "error.log".

### Permanent redirections <a id="ROIS-PR">[≡](#≡)</a>

If you have lots of data that you’re redirecting in your script, it can get tedious having to redirect every echo statement. Instead, you can tell the shell to redirect a specific file descriptor for the duration of the script by using the `exec` command:   
```
#!/bin/bash

$ cat redirect.sh 
#!/bin/bash
exec 1> debug.log
exec 2> error.log

ls -al read.sh redirect.sh badfile

$ ./redirect.sh

$ cat error.log 
ls: cannot access badfile: No such file or directory

$ cat debug.log 
-rwxrw-r--. 1 setamv setamv 105 Apr  6 06:13 read.sh
-rwxrw-r--. 1 setamv setamv  84 Apr  6 07:17 redirect.sh
```

The exec command starts a new shell, and redirects the STDOUT and STDERR file descriptor to the file "debug.log" and "error.log" seperately.

You can also redirect the STDOUT and STDERR in the middle of a script.

**_Notice_**
Once you redirect STDOUT or STDERR, you can’t easily redirect them back to their original location. If you need to switch back and forth with your redirection, there’s a trick you’ll need to learn. Reference [Creating Your Own Redirection](#CYOR) section later.


## Redirecting Input in Scripts <a id="RIIS">[≡](#≡)</a>

You can use the same technique used to redirect STDOUT and STDERR in your scripts to redirect STDIN from the keyboard. The exec command allows you to redirect STDIN to a file on the Linux system:   
`exec 0< testfile`

This command informs the shell that it should retrieve input from the file testfile instead of STDIN. This redirection applies anytime the script requests input. Here’s an example of this in action:    
```
#!/bin/bash

$ cat data
setamv
susie
angel
anhong is the son of setamv and susie.

$ cat read.sh 
#!/bin/bash
exec 0< data

count=1
while read line
do
   echo "The $count line: $line"
   ((count=count+1))
done

$ ./read.sh 
The 1 line: setamv
The 2 line: susie
The 3 line: angel
The 4 line: anhong is the son of setamv and susie.
```

## Creating Your Own Redirection <a id="CYOR">[≡](#≡)</a>

When you redirect input and output in your script, you’re not limited to the three default file descriptors. I mentioned that you could have up to nine open file descriptors in the shell. The other six file descriptors are numbered from three through eight and are available for you to use as either input or output redirection. You can assign any of these file descriptors to a file, then use them in your scripts as well. This section shows how to use the other file descriptors in your scripts.

### Creating output file descriptors <a id="CYOR-COFD">[≡](#≡)</a>

You assign a file descriptor for output by using the `exec` command. Just as with the standard file descriptors, once you assign an alternative file descriptor to a file location, that redirection stays permanent until you reassign it. Here’s a simple example of using an alternative file descriptor in a script:    
```
#!/bin/bash

$ cat redirect.sh 
#!/bin/bash
exec 3> custom.log

echo "Give some custom message." >&3

$ ./redirect.sh
$ cat custom.log 
Give some custom message.
```

The script uses the `exec` command to redirect file descriptor 3 to an alternative file location named "custom.log". This allows you to keep normal output for the monitor, and redirect special information to files, such as log files for debug or warn or trace.


### Redirecting file descriptors <a id="CYOR-RFD">[≡](#≡)</a>

You can assign an alternative file descriptor to a standard file descriptor, and vice versa. This means that you can redirect the original location of STDOUT to an alternative file descriptor, then redirect that file descriptor back to STDOUT, for example:    
```
#!/bin/bash

$ cat redirect.sh 
#!/bin/bash
exec 3>&1
exec 1> debug.log
echo "This should be stored in the file 'debug.log'"
echo "Output to file descriptor 3" >&3

exec 1>&3
echo "Now output should be back to normal 'terminal'"

$ ./redirect.sh 
Output to file descriptor 3
Now output should be back to normal 'terminal'

$ cat debug.log 
This should be stored in the file 'debug.log'
```

1. First, the script redirects file descriptor 3 to the current location of file descriptor 1, which is STDOUT. This means that any output sent to file descriptor 3 will go to the monitor.     
2. The second exec command redirects STDOUT to a file. The shell will now redirect any output sent to STDOUT directly to the output file. However, file descriptor 3 still points to the original location of STDOUT, which is the monitor.      
3. The script then redirects STDOUT to the current location of file descriptor 3, which is still set to the monitor. This means that now STDOUT is pointing to its original location, the monitor.

### Creating input file descriptors <a id="CYOR-CIFD">[≡](#≡)</a>

You can redirect input file descriptors exactly the same way as output file descriptors. Save the STDIN file descriptor location to another file descriptor before redirecting it to a file, then when you’re done reading the file you can restore STDIN to its original location:  
```
#!/bin/bash

$ cat data
setamv
susie
angel
anhong is the son of setamv and susie.

$ cat redirect.sh 
#!/bin/bash
exec 6<&0
exec 0< data

count=1
while read line
do
   echo "The $count line: $line"
   ((count = count + 1))
done

read -p "Get input from file descriptor 6: " msg <&6
echo "The msg is: $msg"

exec 0<&6

read -p "Back to origin input, are you happy with it[Y/N]?" -n 1 -t 5 answer

echo
echo "your answer is: $answer"

$ ./redirect.sh 
The 1 line: setamv
The 2 line: susie
The 3 line: angel
The 4 line: anhong is the son of setamv and susie.
Get input from file descriptor 6: really?
The msg is: really?
Back to origin input, are you happy with it[Y/N]?N
your answer is: N
```

In this example, file descriptor 6 is used to hold the location for STDIN and you can use `<&6` to read input from it. The script then redirects STDIN to a file. All of the input for the read command comes from the redirected STDIN, which is now the input file. 

When all of the lines have been read, the script returns STDIN to its original location by redirecting it to file descriptor 6.


### Creating a read/write file descriptor <a id="CYOR-CARWFD">[≡](#≡)</a>

You can open a single file descriptor for both input and output. You can then use the same file descriptor to both read data from a file and write data to the same file.

You need to be especially careful with this method though. As you read and write data to and from a file, the shell maintains an internal pointer, indicating where it is in the file. Any reading or writing occurs where the file pointer last left off. This can produce some interesting results if you’re not careful. Take a look at this example:   
```
#!/bin/bash

$ cat testfile
First line
Second line
Third line

$ cat redirect.sh
#!/bin/bash
exec 3<> testfile

read line <&3
echo "Read: $line"

echo "A new line." >&3

$ ./redirect.sh
Read: First line

$ cat testfile
First line
A new line.
Third line
```

This example uses the exec command to assign file descriptor 3 for both input and output sent to and from the file testfile. 

When you display the contents of the testfile file after running the script, you’ll see that the data written to the file overwrote the second line of existing data. 

When the script writes data to the file, it starts where the file pointer is located. The read command reads the first line of data, so it left the file pointer pointing to the first character in the second line of data. When the echo statement outputs data to the file, it places the data at the current location of the file pointer, overwriting whatever data was there

### Closing file descriptors <a id="CYOR-CFD">[≡](#≡)</a>

If you create new input or output file descriptors, the shell automatically closes them when the script exits. There are situations though when you need to manually close a file descriptor before the end of the script.

To close a file descriptor, redirect it to the special symbol `&-`. This is how this looks in the script:     
`exec 3>&-`

This statement closes file descriptor 3, preventing it from being used any more in the script. If you use a closed file descriptor, it'll give you an error like "3: Bad file descriptor".


## Listing Open File Descriptors <a id="LOFD">[≡](#≡)</a>

The `lsof` command lists all of the open file descriptors on the entire Linux system.

The `lsof` command produces an amazing amount of output. It displays information about  
open on the Linux system. This includes all of the processes running on background, as well as any user accounts logged in to the system.

Here is partial output of the `lsof` command:   
```
$ lsof -a -p $$ -d 0,1,2
COMMAND  PID   USER   FD   TYPE DEVICE SIZE/OFF NODE NAME
bash    2539 setamv    0u   CHR  136,1      0t0    4 /dev/pts/1
bash    2539 setamv    1u   CHR  136,1      0t0    4 /dev/pts/1
bash    2539 setamv    2u   CHR  136,1      0t0    4 /dev/pts/1

```
The `-p` option allows you to specify process IDs, which allows you to specify a process ID, The `$$` is the environment variable which stores the current PID of the process. and
`-d` option allows you to specify the file descriptor numbers to display. The `-a` option is used to AND the results of the `-p` and `-d` options.

The table bellow shows the description of each column of the output:    

| **Column** |                           **Descriptioin**                          |
|------------|---------------------------------------------------------------------|
| COMMAND    | The first nine characters of the name of the command in the process |
| PID        | The process ID of the process                                       |
| USER       | The login name of the user who owns the process                     |
| FD         | The file descriptor number and access type                          |
|            | (r - read, w - write, u - read/write)                               |
| TYPE       | The type of file                                                    |
|            | (CHR - character, BLK - block, DIR - directory, REG - regular file) |
| DEVICE     | The device numbers (major and minor) of the device                  |
| SIZE       | If available, the size of the file                                  |
| NODE       | The node number of the local file                                   |
| NAME       | The name of the file                                                |

let’s take a look at the results of the lsof command from inside a script that’s opened a
couple of alternative file descriptors:   
```
#!/bin/bash

$ cat redirect.sh
#!/bin/bash
exec 3> testfile
exec 6< testfile

lsof -a -p $$ -d 0,1,2,3,6

$ ./redirect.sh
COMMAND    PID   USER   FD   TYPE DEVICE SIZE/OFF      NODE NAME
redirect. 2878 setamv    0u   CHR  136,1      0t0         4 /dev/pts/1
redirect. 2878 setamv    1u   CHR  136,1      0t0         4 /dev/pts/1
redirect. 2878 setamv    2u   CHR  136,1      0t0         4 /dev/pts/1
redirect. 2878 setamv    3w   REG    8,3        0 106449722 /home/setamv/shellex/testfile
redirect. 2878 setamv    6r   REG    8,3        0 106449722 /home/setamv/shellex/testfile
```

The script creates two alternative file descriptors, one for output (3) and one for input (6). When the script runs the `lsof` command, you can see the new file descriptors in the output. The filename shows the complete pathname for the files used in the file descriptors.



