[Back](index.md)

# Presenting Data

# Profile
- Book: Linux Command Line and Shell Scripting Bible
- Chapter: Chapter 12: Presenting Data
- Pages: {, }
- Reading Time: 06/04/2017 21:15 ~ 07/04/2017 20:09

# Content Navigation <a id="≡"></a>
- [Understanding Input and Output](#UIAO)
  + [Standard file descriptors](#UIAO-SFD)
    * [STDIN](#UIAO-SFD-STDIN)
    * [STDOUT](#UIAO-SFD-STDOUT)
    * [STDERR](#UIAO-SFD-STDERR)
  + [Redirecting errors](#UIAO-RE)
    * [Redirecting just errors](#UIAO-RE-RJE)
    * [Redirecting errors and data](#UIAO-RE-READ)
- [Redirecting Output in Scripts](#ROIS)
  + [Temporary redirections](#ROIS-TR)
  + [Permanent redirections](#ROIS-PR)
- [Redirecting Input in Scripts](#RIIS)
- [Creating Your Own Redirection](#CYOD)
  + [Creating output file descriptors](#CYOR-COFD)
  + [Redirecting file descriptors](#CYOR-RFD)
  + [Creating input file descriptors](#CYOR-CIFD)
  + [Creating a read/write file descriptor](#CYOR-CARWFD)
  + [Closing file descriptors](#CYOR-CFD)
- [Listing Open File Descriptors](#LOFD)
- [Suppressing Command Output](#SCO)
- [Using Temporary Files](#UTF)
  + [Creating a local temporary file](#UTF-CALTF)
  + [Creating a temporary file in /tmp](#UTF-CATFIT)
  + [Creating a temporary directory](#UTF-CATD)
- [Logging Messages](#LM)
- [Summary](#S)
  + [输入输出和文件描述符的关系](#S-IOFD)

# Reading Notes

## Understanding Input and Output <a id="UIAO">[≡](#≡)</a>

### Standard file descriptors <a id="UIAO-SFD">[≡](#≡)</a>

The Linux system handles every object as a file. This includes the input and output process. Linux identifies each file object using a file descriptor. The file descriptor is a non-negative integer, which uniquely identifies open files in a session. Each process is allowed to have up to nine open file descriptors at a time. The bash shell reserves the first three file descriptors (0, 1, and 2) for special purposes. These are shown in the following table:    

| **File Descriptor** | **Abbreviation** |  Description**  |
|---------------------|------------------|-----------------|
|                   0 | STDIN            | Standard Input  |
|                   1 | STDOUT           | Standard Output |
|                   2 | STDERR           | Standard Error  |

These three special file descriptors handle the input and output from your script. The shell uses them to direct the default input and output in the shell to the appropriate location (which by default is usually your monitor).    


#### STDIN <a id="UIAO-SFD-STDIN">[≡](#≡)</a>

The `STDIN` file descriptor references the standard input to the shell. For a terminal interface, the standard input is the keyboard. The shell receives input from the  keyboard on the STDIN file descriptor, and processes each character as you type it.

When you use the input redirect symbol (<), Linux replaces the standard input file descriptor with the file referenced by the redirection. It reads the file and retrieves data just as if it were typed on the keyboard。

Many bash commands accept input from STDIN, especially if no files are specified on the command line. Here’s an example of using the `cat` command with data entered from STDIN: 
```
$ cat
this is a test
this is a test
```
When you enter the cat command on the command line by itself, it accepts input from STDIN. As you enter each line, the cat command echoes the line to the display.

However, you can also use the STDIN redirect symbol to force the cat command to accept input from another file other than STDIN:    
```
$ cat < data
setamv
susie
angel
anhong is the son of setamv and susie.
```

Now the `cat` command uses the lines that are contained in the testfile file as the input. You can use this technique to input data to any shell command that accepts data from STDIN.


#### STDOUT <a id="UIAO-SFD-STDOUT">[≡](#≡)</a>

The STDOUT file descriptor references the standard output for the shell. On a terminal interface, the standard output is the terminal monitor. All output from the shell (including programs and scripts you run in the shell) is directed to the standard output, which is the monitor.


#### STDERR <a id="UIAO-SFD-STDERR">[≡](#≡)</a>

The shell handles error messages using the special STDERR file descriptor. The STDERR file descriptor references the standard error output for the shell. This is the location where the shell sends error messages generated by the shell or programs and scripts running in the shell.

By default, the STDERR file descriptor points to the same place as the STDOUT file descriptor (even though they are assigned different file descriptor values). This means that, by default, all error messages go to the monitor display.

### Redirecting errors <a id="UIAO-RE">[≡](#≡)</a>

You’ve already seen how to redirect the STDOUT data by using the redirection symbol. Redirecting the STDERR data isn’t much different, you just need to define the STDERR file descriptor when you use the redirection symbol. There are a couple of ways to do this.

#### Redirecting just errors <a id="UIAO-RE-RJE">[≡](#≡)</a>

The STDERR file descriptor is set to the value 2. You can select to redirect
only error messages by placing this file descriptor value immediately before the redirection symbol. The value must appear immediately before the redirection symbol or it won’t work (the _badfile_ bellow is not exists):    
```
$ ls -al badfile 2> test4
$ cat test4
ls: cannot access badfile: No such file or directory
```

Now when you run the command, the error message doesn’t appear on the monitor. Instead,  the output file contains any error messages that are generated by the command. Using this method, the shell only redirects the error messages, not the normal data.

#### Redirecting errors and data <a id="UIAO-RE-READ">[≡](#≡)</a>

If you want to redirect both errors and the normal output, you’ll need to use two redirection symbols. You need to precede each with the appropriate file descriptor for the data you want to redirect, then have them point to the appropriate output file for holding the data:   
```
$ ls -al test test2 test3 badtest 2> test6 1> test7
$ cat test6
ls: cannot access test: No such file or directory
ls: cannot access badtest: No such file or directory
$ cat test7
-rw-rw-r-- 1 rich rich 158 2007-10-26 11:32 test2
-rw-rw-r-- 1 rich rich 0 2007-10-26 11:33 test3
```
The shell redirects the normal output of the `ls` command that would have gone to STDOUT to the test7 file using the `1>` symbol. Any error messages that would have gone to STDERR were redirected to the test6 file using the `2>` symbol.

You can use this technique to separate normal script output from any error messages that occur in the script.  

Alternatively, if you want, you can redirect both STDERR and STDOUT output to the same output file. The bash shell provides a special redirection symbol just for this purpose, the `&>` symbol:       
```
$ ls -al test test2 test3 badtest &> test7
$ cat test7
ls: cannot access test: No such file or directory
ls: cannot access badtest: No such file or directory
-rw-rw-r-- 1 rich rich 158 2007-10-26 11:32 test2
-rw-rw-r-- 1 rich rich 0 2007-10-26 11:33 test3
```
Using the &> symbol, all of the output generated by the command is sent to the same location, both data and errors. You’ll notice that one of the error messages is out of order from what you’d expect. The error message for the badtest file (the last file to be listed) appears second in the output file. The bash shell automatically gives error messages a higher priority than the standard output. This allows you to view the error messages together, rather than scattered throughout the output file.


## Redirecting Output in Scripts <a id="ROIS">[≡](#≡)</a>

You can use the STDOUT and STDERR file descriptors in your scripts to produce output in
multiple locations simply by redirecting the appropriate file descriptors. There are two methods for redirecting output in the script:

1. Temporarily redirecting each line
2. Permanently redirecting all commands in the script


### Temporary redirections <a id="ROIS-TR">[≡](#≡)</a>

If you want to purposely generate error messages in your script, you can redirect an individual output line to STDERR. All you need to do is use the output redirection symbol to redirect the output to the STDERR file descriptor. When you redirect to a file descriptor, you must precede the file descriptor number with an ampersand sign (&):    
`echo "This is an error message" >&2`

This line displays the text wherever the STDERR file descriptor for the script is pointing, instead of the normal STDOUT. Here’s an example of a script that uses this feature:    
```
#!/bin/bash

$ cat stderr.sh 
#!/bin/bash
echo "This is a manually created error output." >&2
echo "This is a normal output."
```

If you run the script as normal, you won’t notice any difference as by default Linux directs the STDERR output to STDOUT:        
```
$ ./stderr.sh 
This is a manually created error output.
This is a normal output.
```

However, if you redirect STDERR when running the script, any text directed to STDERR in the script will be redirected:    
```
$ ./stderr.sh 2> error.log
This is a normal output.

$ cat error.log
This is a manually created error output.
```

Perfect! The text that’s displayed using STDOUT appears on the monitor, while the echo statement text sent to STDERR is redirected to the output file "error.log".

### Permanent redirections <a id="ROIS-PR">[≡](#≡)</a>

If you have lots of data that you’re redirecting in your script, it can get tedious having to redirect every echo statement. Instead, you can tell the shell to redirect a specific file descriptor for the duration of the script by using the `exec` command:   
```
#!/bin/bash

$ cat redirect.sh 
#!/bin/bash
exec 1> debug.log
exec 2> error.log

ls -al read.sh redirect.sh badfile

$ ./redirect.sh

$ cat error.log 
ls: cannot access badfile: No such file or directory

$ cat debug.log 
-rwxrw-r--. 1 setamv setamv 105 Apr  6 06:13 read.sh
-rwxrw-r--. 1 setamv setamv  84 Apr  6 07:17 redirect.sh
```

The exec command starts a new shell, and redirects the STDOUT and STDERR file descriptor to the file "debug.log" and "error.log" seperately.

You can also redirect the STDOUT and STDERR in the middle of a script.

**_Notice_**
Once you redirect STDOUT or STDERR, you can’t easily redirect them back to their original location. If you need to switch back and forth with your redirection, there’s a trick you’ll need to learn. Reference [Creating Your Own Redirection](#CYOR) section later.


## Redirecting Input in Scripts <a id="RIIS">[≡](#≡)</a>

You can use the same technique used to redirect STDOUT and STDERR in your scripts to redirect STDIN from the keyboard. The exec command allows you to redirect STDIN to a file on the Linux system:   
`exec 0< testfile`

This command informs the shell that it should retrieve input from the file testfile instead of STDIN. This redirection applies anytime the script requests input. Here’s an example of this in action:    
```
#!/bin/bash

$ cat data
setamv
susie
angel
anhong is the son of setamv and susie.

$ cat read.sh 
#!/bin/bash
exec 0< data

count=1
while read line
do
   echo "The $count line: $line"
   ((count=count+1))
done

$ ./read.sh 
The 1 line: setamv
The 2 line: susie
The 3 line: angel
The 4 line: anhong is the son of setamv and susie.
```

## Creating Your Own Redirection <a id="CYOR">[≡](#≡)</a>

When you redirect input and output in your script, you’re not limited to the three default file descriptors. I mentioned that you could have up to nine open file descriptors in the shell. The other six file descriptors are numbered from three through eight and are available for you to use as either input or output redirection. You can assign any of these file descriptors to a file, then use them in your scripts as well. This section shows how to use the other file descriptors in your scripts.

### Creating output file descriptors <a id="CYOR-COFD">[≡](#≡)</a>

You assign a file descriptor for output by using the `exec` command. Just as with the standard file descriptors, once you assign an alternative file descriptor to a file location, that redirection stays permanent until you reassign it. Here’s a simple example of using an alternative file descriptor in a script:    
```
#!/bin/bash

$ cat redirect.sh 
#!/bin/bash
exec 3> custom.log

echo "Give some custom message." >&3

$ ./redirect.sh
$ cat custom.log 
Give some custom message.
```

The script uses the `exec` command to redirect file descriptor 3 to an alternative file location named "custom.log". This allows you to keep normal output for the monitor, and redirect special information to files, such as log files for debug or warn or trace.


### Redirecting file descriptors <a id="CYOR-RFD">[≡](#≡)</a>

You can assign an alternative file descriptor to a standard file descriptor, and vice versa. This means that you can redirect the original location of STDOUT to an alternative file descriptor, then redirect that file descriptor back to STDOUT, for example:    
```
#!/bin/bash

$ cat redirect.sh 
#!/bin/bash
exec 3>&1
exec 1> debug.log
echo "This should be stored in the file 'debug.log'"
echo "Output to file descriptor 3" >&3

exec 1>&3
echo "Now output should be back to normal 'terminal'"

$ ./redirect.sh 
Output to file descriptor 3
Now output should be back to normal 'terminal'

$ cat debug.log 
This should be stored in the file 'debug.log'
```

1. First, the script redirects file descriptor 3 to the current location of file descriptor 1, which is STDOUT. This means that any output sent to file descriptor 3 will go to the monitor.     
2. The second exec command redirects STDOUT to a file. The shell will now redirect any output sent to STDOUT directly to the output file. However, file descriptor 3 still points to the original location of STDOUT, which is the monitor.      
3. The script then redirects STDOUT to the current location of file descriptor 3, which is still set to the monitor. This means that now STDOUT is pointing to its original location, the monitor.

### Creating input file descriptors <a id="CYOR-CIFD">[≡](#≡)</a>

You can redirect input file descriptors exactly the same way as output file descriptors. Save the STDIN file descriptor location to another file descriptor before redirecting it to a file, then when you’re done reading the file you can restore STDIN to its original location:  
```
#!/bin/bash

$ cat data
setamv
susie
angel
anhong is the son of setamv and susie.

$ cat redirect.sh 
#!/bin/bash
exec 6<&0
exec 0< data

count=1
while read line
do
   echo "The $count line: $line"
   ((count = count + 1))
done

read -p "Get input from file descriptor 6: " msg <&6
echo "The msg is: $msg"

exec 0<&6

read -p "Back to origin input, are you happy with it[Y/N]?" -n 1 -t 5 answer

echo
echo "your answer is: $answer"

$ ./redirect.sh 
The 1 line: setamv
The 2 line: susie
The 3 line: angel
The 4 line: anhong is the son of setamv and susie.
Get input from file descriptor 6: really?
The msg is: really?
Back to origin input, are you happy with it[Y/N]?N
your answer is: N
```

In this example, file descriptor 6 is used to hold the location for STDIN and you can use `<&6` to read input from it. The script then redirects STDIN to a file. All of the input for the read command comes from the redirected STDIN, which is now the input file. 

When all of the lines have been read, the script returns STDIN to its original location by redirecting it to file descriptor 6.


### Creating a read/write file descriptor <a id="CYOR-CARWFD">[≡](#≡)</a>

You can open a single file descriptor for both input and output. You can then use the same file descriptor to both read data from a file and write data to the same file.

You need to be especially careful with this method though. As you read and write data to and from a file, the shell maintains an internal pointer, indicating where it is in the file. Any reading or writing occurs where the file pointer last left off. This can produce some interesting results if you’re not careful. Take a look at this example:   
```
#!/bin/bash

$ cat testfile
First line
Second line
Third line

$ cat redirect.sh
#!/bin/bash
exec 3<> testfile

read line <&3
echo "Read: $line"

echo "A new line." >&3

$ ./redirect.sh
Read: First line

$ cat testfile
First line
A new line.
Third line
```

This example uses the exec command to assign file descriptor 3 for both input and output sent to and from the file testfile. 

When you display the contents of the testfile file after running the script, you’ll see that the data written to the file overwrote the second line of existing data. 

When the script writes data to the file, it starts where the file pointer is located. The read command reads the first line of data, so it left the file pointer pointing to the first character in the second line of data. When the echo statement outputs data to the file, it places the data at the current location of the file pointer, overwriting whatever data was there

### Closing file descriptors <a id="CYOR-CFD">[≡](#≡)</a>

If you create new input or output file descriptors, the shell automatically closes them when the script exits. There are situations though when you need to manually close a file descriptor before the end of the script.

To close a file descriptor, redirect it to the special symbol `&-`. This is how this looks in the script:     
`exec 3>&-`

This statement closes file descriptor 3, preventing it from being used any more in the script. If you use a closed file descriptor, it'll give you an error like "3: Bad file descriptor".


## Listing Open File Descriptors <a id="LOFD">[≡](#≡)</a>

The `lsof` command lists all of the open file descriptors on the entire Linux system.

The `lsof` command produces an amazing amount of output. It displays information about  
open on the Linux system. This includes all of the processes running on background, as well as any user accounts logged in to the system.

Here is partial output of the `lsof` command:   
```
$ lsof -a -p $$ -d 0,1,2
COMMAND  PID   USER   FD   TYPE DEVICE SIZE/OFF NODE NAME
bash    2539 setamv    0u   CHR  136,1      0t0    4 /dev/pts/1
bash    2539 setamv    1u   CHR  136,1      0t0    4 /dev/pts/1
bash    2539 setamv    2u   CHR  136,1      0t0    4 /dev/pts/1

```
The `-p` option allows you to specify process IDs, which allows you to specify a process ID, The `$$` is the environment variable which stores the current PID of the process. and
`-d` option allows you to specify the file descriptor numbers to display. The `-a` option is used to AND the results of the `-p` and `-d` options.

The table bellow shows the description of each column of the output:    

| **Column** |                           **Descriptioin**                          |
|------------|---------------------------------------------------------------------|
| COMMAND    | The first nine characters of the name of the command in the process |
| PID        | The process ID of the process                                       |
| USER       | The login name of the user who owns the process                     |
| FD         | The file descriptor number and access type                          |
|            | (r - read, w - write, u - read/write)                               |
| TYPE       | The type of file                                                    |
|            | (CHR - character, BLK - block, DIR - directory, REG - regular file) |
| DEVICE     | The device numbers (major and minor) of the device                  |
| SIZE       | If available, the size of the file                                  |
| NODE       | The node number of the local file                                   |
| NAME       | The name of the file                                                |

let’s take a look at the results of the lsof command from inside a script that’s opened a
couple of alternative file descriptors:   
```
#!/bin/bash

$ cat redirect.sh
#!/bin/bash
exec 3> testfile
exec 6< testfile

lsof -a -p $$ -d 0,1,2,3,6

$ ./redirect.sh
COMMAND    PID   USER   FD   TYPE DEVICE SIZE/OFF      NODE NAME
redirect. 2878 setamv    0u   CHR  136,1      0t0         4 /dev/pts/1
redirect. 2878 setamv    1u   CHR  136,1      0t0         4 /dev/pts/1
redirect. 2878 setamv    2u   CHR  136,1      0t0         4 /dev/pts/1
redirect. 2878 setamv    3w   REG    8,3        0 106449722 /home/setamv/shellex/testfile
redirect. 2878 setamv    6r   REG    8,3        0 106449722 /home/setamv/shellex/testfile
```

The script creates two alternative file descriptors, one for output (3) and one for input (6). When the script runs the `lsof` command, you can see the new file descriptors in the output. The filename shows the complete pathname for the files used in the file descriptors.


## Suppressing Command Output <a id="SCO">[≡](#≡)</a>

There are times when you don’t want to display any output from your script. To solve that problem, you can redirect STDERR to a special file called the _null_ file. The _null_ file is pretty much what it says it is, a file that contains nothing. Any data that the shell outputs to the null file is not saved, thus lost.

The standard location for the null file on Linux systems is _/dev/null_. Any data you redirect to that location is thrown away and doesn’t appear:    
```
$ ls -al > /dev/null
$ cat /dev/null
```

This is a common way to suppress any error messages without actually saving them:   
```
$ ls -al badfile testfile 2> /dev/null
-rwxr--r-- 1 setamv setamv 135 Oct 29 19:57 testfile
```

You can also use the _/dev/null_ file for input redirection as an input file. Since the _/dev/null_ file contains nothing, it is often used by programmers to quickly remove data from an existing file without having to remove the file and recreate it:    
```
$ cat data
setamv
susie
angel
anhong is the son of setamv and susie.

$ cat /dev/null > data
$ cat data
```

The file "data" still exists on the system, but now it is empty.


## Using Temporary Files <a id="UTF">[≡](#≡)</a>

The Linux system contains a special directory location reserved for temporary files. Linux uses the _/tmp_ directory for files that don’t need to be kept indefinitely. Most Linux distributions configure the system to automatically remove any files in the _/tmp_ directory at bootup.

This feature provides an easy way for you to create temporary files that you don’t necessarily have to worry about cleaning up.

The `mktemp` command allows you to easily create a unique temporary file in the _/tmp_ folder. The shell creates the file but doesn’t use your default umask value. Instead, it only assigns read and write permissions to the file’s owner and makes you the owner of the file. Once you create the file, you have full access to read and write to and from it from your script, but no one else will be able to access it (other than the root user of course).


### Creating a local temporary file <a id="UTF-CALTF">[≡](#≡)</a>

By default, `mktemp` creates a file in the local directory. To create a temporary file in a local directory with the `mktemp` command, all you need to do is specify a filename template. The template consists of any text filename, plus six X’s appended to the end of the filename:    
```
$ mktemp testing.XXXXXX
$ ls -al testing*
-rw------- 1 rich rich 0 Oct 29 21:30 testing.UfIi13
```

The mktemp command replaces the six X’s with a six-character code to ensure the filename is unique in the directory. You can create multiple temporary files and be assured that each one is unique:      
```
$ mktemp testing.XXXXXX
testing.1DRLuV
$ mktemp testing.XXXXXX
testing.lVBtkW
$ mktemp testing.XXXXXX
testing.PgqNKG
$ ls -l testing*
-rw------- 1 rich rich 0 Oct 29 21:57 testing.1DRLuV
-rw------- 1 rich rich 0 Oct 29 21:57 testing.PgqNKG
-rw------- 1 rich rich 0 Oct 29 21:30 testing.UfIi13
-rw------- 1 rich rich 0 Oct 29 21:57 testing.lVBtkW
```

The output of the `mktemp` command is the name of the file that it creates. When you use the `mktemp` command in a script, you’ll want to save that filename in a variable, so you can refer to it later on in the script:    
```
#!/bin/bash

$ cat temp.sh
#!/bin/bash
tempfilename=`mktemp test.XXXXXX`
exec 3> $tempfilename
echo "This script writes to temp file $tempfile"
echo "This is the first line" >&3
echo "This is the second line." >&3
```

### Creating a temporary file in /tmp <a id="UTF-CATFIT">[≡](#≡)</a>

The `-t` option forces `mktemp` to create the file in the temporary directory of the system. When you use this feature, the `mktemp` command returns the full pathname used to create the temporary file, not just the filename:    
```
$ mktemp -t tempfile.XXXXXX
/tmp/tempfile.UlSP4N
$ ls /tmp/tempfile*
/tmp/tempfile.UlSP4N
```

### Creating a temporary directory <a id="UTF-CATD">[≡](#≡)</a>

The -d option tells the mktemp command to create a temporary directory instead of a file. You can then use that directory for whatever purposes you need, such as creating additional temporary files:    
```
$ mktemp -d tmpdir.XXXXXX
tmpdir.MTqk5i
$ mktemp -d -t tmpdir.XXXXXX
/tmp/tmpdir.9dsMxm
```


## Logging Messages <a id="LM">[≡](#≡)</a>

The `tee` command is like a T-connector for pipes. It sends data from STDIN to two destinations at the same time. One destination is STDOUT. The other destination is a filename specified on the `tee` command line:   
`tee filename`

Since tee redirects data from STDIN, you can use it with the pipe command to redirect output from any command:    
```
$ date | tee testfile
Fri Apr  7 04:58:09 PDT 2017
$ cat testfile
Fri Apr  7 04:58:09 PDT 2017
```

Be careful: by default, the `tee` command overwrites the output file on each use, If you want to append data to the file, you must use the `-a` option:   
```
$ date | tee -a testfile
Fri Apr  7 04:59:57 PDT 2017
$ cat testfile
Fri Apr  7 04:58:09 PDT 2017
Fri Apr  7 04:59:57 PDT 2017
```


## Summary <a id="S">[≡](#≡)</a>

### 输入输出和文件描述符的关系   <a id="S-IOFD">[≡](#≡)</a>

可以将输入输出和文件描述符的关系，描述为 _需求方_ 和 _实现方_ 的关系。     
文件描述符用于将具体的 _需求方_ 和具体的 _实现方_ 关联起来。    
例如：

- 对于输入来说，需要获取输入信息的一方（如read命令和cat命令）为 _需求方_ ，而提供信息的一方（如键盘输入或一个文件）为 _实现方_

- 对于输出来说，一段文本信息（如日志信息）为 _需求方_，因为这一段文本信息要么需要展示到显示器或保存到文件，而标准输出和保存数据的文件为 _实现方_ ，它们实现了打印信息或保存数据的需求

文件描述符用于将需求方和实现方关联起来，媒文件描述符只是起到一个中间介的作用    

- 将需求方和文件描述符关联起来时，使用 输入输出符号('<', '>') 后跟与符号(&)以及文件描述符值的格式，如 `read <&0`，`read <&5`，`echo >&2`，`echo >&6`

- 将文件描述符与实现方关联起来时，使用 文件描述符值 后跟 输入输出符号('<', '>') 的格式，如 `1> data.file`，`5< data.file`。而如果是引用另一个文件描述符关联的 _实现方_，可以使用如下方式：`5>&6`，即将文件描述符6关联到的 _实现方_ 也关联到 文件描述符5，例如，使用 `ls -al > list.data 2>&1`即可将标准输出(1>)和标准错误输出(2>)都关联到（即重定向）到list.data文件。
