[Back](index.md)

# Script Control

# Profile
- Book: Linux Command Line and Shell Scripting Bible
- Chapter: Chapter 13: Script Control
- Pages: {, }
- Reading Time: 06/04/2017 21:15

# Content Navigation <a id="≡"></a>
- [Handling Signals](#HS)
  + [Linux signals revisited](#HS-LSR)
  + [Generating signals](#HS-GS)
    * [Interrupting a process](#HS-GS-IAP)
    * [Pausing a process](#HS-GS-PAP)
  + [Trapping signals](#HS-TS)
  + [Trapping a script exit](#HS-TASE)
  + [Removing a trap](#HS-RAT)
- [Running Scripts in Background Mode](#RSIBM)
  + [Running in the background](#RSIBM-RITB)
  + [Running multiple background jobs](#RSIBM-RMBJ)
- [Running Scripts without a Console](#RSWAC)
- [Job Control](#JC)
  + [Viewing jobs](#JC-VJ)
  + [Restarting stopped jobs](#JC-RSJ)
- [Being Nice](#BN)

# Reading Notes

## Handling Signals <a id="HS">[≡](#≡)</a>

Linux uses signals to communicate with processes running on the system. Chapter 4 described the different Linux signals and how the Linux system uses these signals to stop, start, and kill processes. You can also use these signals to control the operation of your shell scripts by programming your shell script to perform commands when it receives specific signals from the Linux system.


### Linux signals revisited <a id="HS-LSR">[≡](#≡)</a>

There are over 30 Linux signals that can be generated by the system and
applications. The following table lists the most common Linux system signals that
you’ll run across in your Linux programming:    

| **Signal** | **Name** |                  **Description**                  |
|------------|----------|---------------------------------------------------|
|          1 | SIGHUP   | Hang up.                                          |
|          2 | SIGINT   | Interrupt.                                        |
|          3 | SIGQUIT  | Stop running.                                     |
|          9 | SIGKILL  | Unconditionally terminate.                        |
|         11 | SIGSEGV  | Segment violation.                                |
|         15 | SIGTERM  | Terminate if possible.                            |
|         17 | SIGSTOP  | Stop unconditionally, but don’t terminate.        |
|         18 | SIGTSTP  | Stop or pause, but continue to run in background. |
|         19 | SIGCONT  | Resume execution after STOP or TSTP.              |

By default, the bash shell ignores any SIGQUIT (3) and SIGTERM (15) signals that it receives (this is so that an interactive shell can’t be accidentally terminated). However, the bash shell processes any SIGHUP (1) and SIGINT (2) signals it receives.

If the bash shell receives a SIGHUP signal, it exits. Before it exits though, it passes the SIGHUP signal to any processes started by the shell (such as your shell script). With a SIGINT signal, the shell is just interrupted. The Linux kernel stops giving the shell processing time on the CPU. When this happens, the shell passes the SIGINT signal to any processes started by the shell to notify them of the situation.


### Generating signals <a id="HS-GS">[≡](#≡)</a>

The bash shell allows you to generate two basic Linux signals using key combinations on the keyboard. This feature comes in handy if you need to stop or pause runaway programs.

#### Interrupting a process <a id="HS-GS-IAP">[≡](#≡)</a>

The `Ctrl-C` key combination generates a SIGINT signal, and sends it to any processes currently running in the shell.


#### Pausing a process <a id="HS-GS-PAP">[≡](#≡)</a>

The `Ctrl-Z` key combination generates a SIGTSTP signal, stopping any processes running in the shell. Stopping a process is different than terminating the process, as stopping the process leaves the program still in memory, and able to continue running from where it left off. 

Sometimes this can be a dangerous thing (for example, if a script has a file lock open on a crucial system file)

When you use the Ctrl-Z key combination, the shell informs you that the process has been
stopped, for example:    
```
$ sleep 10
^Z
[1]+  Stopped                 sleep 10
```
The _number_ in the square brackets is the job number assigned by the shell.    
The shell refers to each process running in the shell as a job, and assigns each job a unique job number. It assigns the first process started job number 1, the second job number 2, and so on.

If you have a stopped job assigned to your shell session, bash will warn you if you try to exit the shell:    
```
$ exit
logout
There are stopped jobs.
```

You can view the stopped job by using our friend the ps command:    
```
$ ps au
USER        PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root        665  0.0  0.0 110036   832 tty1     Ss+  04:51   0:00 /sbin/agetty --noclear tty1 linux
root       2160  0.0  0.1 116040  2700 pts/0    Ss   04:51   0:00 -bash
root       2214  0.0  0.1 189760  2452 pts/0    S    04:53   0:00 su - setamv
setamv     2215  0.0  0.1 116176  3012 pts/0    S    04:53   0:00 -bash
setamv     2409  0.0  0.0 107896   604 pts/0    T    05:30   0:00 sleep 10
setamv     2416  0.0  0.0 151056  1820 pts/0    R+   05:36   0:00 ps au
```
The ps command shows the status of the stopped job as T, which indicates the command is either being traced or is stopped.

If you really want to exit the shell with the stopped job still active, just type the exit command again. The shell will exit, terminating the stopped job. You can also use the `kill` command to send a SIGKILL signal to terminate it:
```
$ kill -9 2409
$ echo $?
0
[1]+  Killed                  sleep 10
```
When you kill the job, initially you won’t get any response. However, the next time you do something that produces a shell prompt, you’ll see a message indicating that the job was killed, like the script above.


### Trapping signals <a id="HS-TS">[≡](#≡)</a>

The `trap` command allows you to specify which Linux signals your shell script can watch for and intercept from the shell. If the script receives a signal listed in the `trap` command, it prevents it from being processed by the shell, and instead handles it locally.

The format of the trap command is:   
`trap commands signals`

On the trap command line, you just list the commands you want the shell to execute, along with a space-separated list of signals you want to trap. You can specify the signals either by their numeric value or by their Linux signal name.    

Here’s a simple example of using the trap command to ignore SIGINT and SIGTERM signals:  
```
#!/bin/bash

$ cat trapsig.sh 
#!/bin/bash
trap "echo 'signal received and i just want to ignore them, Hahaha!'" SIGINT SIGTERM
echo "Now the process will take a while for 3 seconds and do 2 times."
count=1
while ((count <= 2))
do
   echo "Loop $count and going to sleep 3 seconds."  
   sleep 3
   ((count = count + 1))
done
echo "This is the end of process."

$ ./trapsig.sh 
Now the process will take a while for 3 seconds and do 4 times.
Loop 1 and going to sleep 3 seconds.
^Csignal received and i just want to ignore them, Hahaha!
Loop 2 and going to sleep 3 seconds.
This is the end of process.
```

When the `Ctrl-C` key combination was used, the script executed the echo statement specified in the `trap` command instead of ignoring the signal and allowing the shell to stop the script, the script still finished the left loop round after `Ctrl-C` is trapped. 


### Trapping a script exit <a id="HS-TASE">[≡](#≡)</a>

Besides trapping signals in your shell script, you can trap them when the shell script exits. This is a convenient way to perform commands just as the shell finishes its job. To trap the shell script exiting, just add the EXIT signal to the trap command:   
```
#!/bin/bash

$ cat trapsig.sh 
#!/bin/bash
trap "echo byebye" EXIT
echo "Now the process will take a while for 3 seconds and do 2 times."
count=1
while ((count <= 2))
do
   echo "Loop $count and going to sleep 3 seconds."  
   sleep 3
   ((count = count + 1))
done
echo "This is the end of process."

$ ./trapsig.sh 
Now the process will take a while for 3 seconds and do 4 times.
Loop 1 and going to sleep 3 seconds.
Loop 2 and going to sleep 3 seconds.
This is the end of process.
byebye

$ ./trapsig.sh 
Now the process will take a while for 3 seconds and do 4 times.
Loop 1 and going to sleep 3 seconds.
^Cbyebye
```

When the script gets to the normal exit point, the trap is triggered, and the shell executes the command you specify on the `trap` command line.

When the `Ctrl-C` key combination is used to send a SIGINT signal, the script exits (since that signal isn’t listed in the trap list), but before the script exits, the shell executes the `trap` command.


### Removing a trap <a id="HS-RAT">[≡](#≡)</a>

You can remove a set trap by using a dash between the `trap` command and a list of the signals you want to return to normal behavior:   
```
#!/bin/bash

$ cat trapsig.sh 
#!/bin/bash
trap "echo byebye" EXIT
echo "Now the process will take a while for 3 seconds and do 4 times."
count=1
while ((count <= 2))
do
   echo "Loop $count and going to sleep 3 seconds."  
   sleep 3
   ((count = count + 1))
done
trap - EXIT
echo "I just removed the EXIT trap"

$ ./trapsig.sh 
Now the process will take a while for 3 seconds and do 4 times.
Loop 1 and going to sleep 3 seconds.
^Cbyebye

$ ./trapsig.sh 
Now the process will take a while for 3 seconds and do 4 times.
Loop 1 and going to sleep 3 seconds.
Loop 2 and going to sleep 3 seconds.
I just removed the EXIT trap
```


## Running Scripts in Background Mode <a id="RSIBM">[≡](#≡)</a>

In background mode, a process runs without being associated with a STDIN, STDOUT, and STDERR on a terminal session.

### Running in the background <a id="RSIBM-RITB">[≡](#≡)</a>

To run a shell script in background mode from the command line interface, just place an ampersand symbol after the command:           
```
#!/bin/bash

$ cat background.sh 
#!/bin/bash
exec 1> debug.log
count=1
while ((count <= 3))
do
   echo "The $count loop, going to sleep 3 seconds."
   sleep 3
   ((count = count + 1))
done
echo "The end of process."

$ ./background.sh &
[1] 2576

$ cat debug.log
The 1 loop, going to sleep 3 seconds.
The 2 loop, going to sleep 3 seconds.
The 3 loop, going to sleep 3 seconds.
The end of process.
[1]+  Done                    ./background.sh
```
When you place the ampersand symbol after a command it runs as a separate background process on the system. The first thing that displays is the line:  
`[1] 2535`
The number in the square brackets is the job number assigned to the background process by the shell. The next number is the PID the Linux system assigns to the process.

After display the job number and PID, a new command line interface prompt immediately appears. You are returned back to the shell, and the command you executed runs safely in background mode. 

When the background process finishes, it displays a message on the terminal:    
`[1]+  Done                    ./background.sh`
This shows the job number and the status of the job (Done), along with the command used to start the job.

### Exiting the terminal <a id="RSIBM-ETT">[≡](#≡)</a>

You must be careful when using background processes from a terminal session. Notice in the output from the ps command that each of the background processes is tied to the terminal session (pts/0) terminal:   
```
$ ./background.sh &
$ ps au
USER        PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
setamv     2215  0.0  0.1 116176  3020 pts/0    S    04:53   0:00 -bash
setamv     2637  0.3  0.0 113124  1384 pts/0    S    06:58   0:00 /bin/bash ./background.sh
setamv     2639  0.0  0.0 107896   604 pts/0    S    06:58   0:00 sleep 3
setamv     2640  0.0  0.0 151056  1824 pts/0    R+   06:58   0:00 ps au
```
If the terminal session exits, the background process also exits.

## Running Scripts without a Console <a id="RSWAC">[≡](#≡)</a>

When you want to start a shell script from a terminal session, then let the script run in background mode until it finishes, even if you exit the terminal session. You can do
this by using the `nohup` command.

The `nohup` command runs another command blocking any SIGHUP signals that are sent to the
process. This prevents the process from exiting when you exit your terminal session.

The format used for the nohup command is:  
```
#!/bin/bash

$ cat background.sh 
#!/bin/bash
count=1
while ((count <= 3))
do
   echo "The $count loop, going to sleep 3 seconds."
   sleep 3
   ((count = count + 1))
done
echo "The end of process."

$ nohup ./background.sh 
nohup: ignoring input and appending output to ‘nohup.out’
$ cat nohup.out
The 1 loop, going to sleep 3 seconds.
The 2 loop, going to sleep 3 seconds.
The 3 loop, going to sleep 3 seconds.
```

Just as with a normal background process, the shell assigns the command a job number, and
the Linux system assigns a PID number. The difference is that when you use the `nohup` command, the script ignores any `SIGHUP` signals sent by the terminal session if you close the session, that means the background process started by `nohup` will not exit even when the shell which started the process exited, this is a main difference between normal background process(use `&` after command) and `nohup`.    

Because the nohup command disassociates the process from the terminal, the process loses the STDOUT and STDERR output links. To accommodate any output generated by the command,
the nohup command automatically redirects STDOUT and STDERR messages to a file, called
"nohup.out".

If you run another command using `nohup`, the output is appended to the existing nohup.out file. Be careful when running multiple commands from the same directory, as all of the output will be sent to the same nohup.out file.


## Job Control <a id="JC">[≡](#≡)</a>

The function of _starting_, _stopping_, _killing_, and _resuming_ jobs is called job control. With job control, you have full control over how processes run in your shell environment.

### Viewing jobs <a id="JC-VJ">[≡](#≡)</a>

The key command for job control is the `jobs` command. The `jobs` command allows you to
view the current jobs being handled by the shell:     
```
#!/bin/bash

$ cat background.sh 
#!/bin/bash
count=1
while ((count <= 3))
do
   echo "The $count loop, going to sleep 3 seconds."
   sleep 3
   ((count = count + 1))
done
echo "The end of process."

$ ./background.sh 
The 1 loop, going to sleep 3 seconds.
^Z
[1]+  Stopped                 ./background.sh

$ ./background.sh > debug.log &
[2] 2718

$ jobs
[1]+  Stopped                 ./background.sh
[2]-  Running                 ./background.sh > debug.log &
```
After the first job started, I used the `Ctrl-Z` key combination to stop the process.
The jobs command shows both the stopped and the running jobs, along with their job numbers and the commands used in the jobs.

The table bellow shows `jobs` command line parameters:  

| **Parameter** |                    **Description**                     |
|---------------|--------------------------------------------------------|
| -l            | List the PID of the process along with the job number. |
| -n            | List only jobs that have changed their status          |
|               | since the last notification from the shell.            |
| -p            | List only the PIDs of the jobs.                        |
| -r            | List only the running jobs.                            |
| -s            | List only stopped jobs.                                |


### Restarting stopped jobs <a id="JC-RSJ">[≡](#≡)</a>

Under bash job control, you can restart any stopped job as either a background process or a foreground process.

To restart a job in background mode, use the `bg` command, along with the job number:  
```
$ jobs
[1]-  Stopped                 ./background.sh
[2]+  Stopped                 ./background.sh

$ bg 2

$ jobs
[1]-  Stopped                 ./background.sh
[2]+  Running                 ./background.sh
```

To restart a job in foreground mode, use the `fg` command, along with the job number, Since the job is running in foreground mode, you won't get a new command line interface prompt until the jobs finishes.

## Being Nice <a id="BN">[≡](#≡)</a>

