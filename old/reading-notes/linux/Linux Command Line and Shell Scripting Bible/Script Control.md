[Back](index.md)

# Script Control

# Profile
- Book: Linux Command Line and Shell Scripting Bible
- Chapter: Chapter 13: Script Control
- Pages: {, }
- Reading Time: 06/04/2017 21:15

# Content Navigation <a id="≡"></a>
- [Handling Signals](#HS)
  + [Linux signals revisited](#HS-LSR)
  + [Generating signals](#HS-GS)
    * [Interrupting a process](#HS-GS-IAP)
    * [Pausing a process](#HS-GS-PAP)
  + [Trapping signals](#HS-TS)
  + [Trapping a script exit](#HS-TASE)
  + [Removing a trap](#HS-RAT)
- [Running Scripts in Background Mode](#RSIBM)
  + [Running in the background](#RSIBM-RITB)
  + [Running multiple background jobs](#RSIBM-RMBJ)
- [Running Scripts without a Console](#RSWAC)
- [Job Control](#JC)
  + [Viewing jobs](#JC-VJ)
  + [Restarting stopped jobs](#JC-RSJ)
- [Being Nice](#BN)
  + [The nice command](#BN-TNC)
  + [The renice command](#BN-TRC)
- [Running Like Clockwork](#RLC)
  + [Scheduling a job using the `at` command](#RLC-SAJUTAC)
    * [The at command format](#RLC-SAJUTAC-TACF)
    * [Retrieving job output](#RLC-SAJUTAC-RJO)
    * [Listing pending jobs](#RLC-SAJUTAC-LPJ)
    * [Removing jobs](#RLC-SAJUTAC-RJ)
  + [Using the batch command](#RLC-UTBC)
  + [Scheduling regular scripts](#RLC-SRS)
    * [The cron table](#RLC-SRS-TCT)
    * [Building the cron table](#RLC-SRS-BTCT)
    * [The anacron program](#RLC-SRS-BTCT-TAP)
- [Start At the Beginning](#SATB)
  + [Start At the Beginning](#SATB)
  + [Starting your scripts at boot](#SATB-SYSAB)
    * [The boot process](#SATB-SYSAB-TBP)
    * [Defining your scripts](#SATB-SYSAB-DYS)
  + [Starting with a new shell](#SATB-SWNS)

# Reading Notes

## Handling Signals <a id="HS">[≡](#≡)</a>

Linux uses signals to communicate with processes running on the system. Chapter 4 described the different Linux signals and how the Linux system uses these signals to stop, start, and kill processes. You can also use these signals to control the operation of your shell scripts by programming your shell script to perform commands when it receives specific signals from the Linux system.


### Linux signals revisited <a id="HS-LSR">[≡](#≡)</a>

There are over 30 Linux signals that can be generated by the system and
applications. The following table lists the most common Linux system signals that
you’ll run across in your Linux programming:    

| **Signal** | **Name** |                  **Description**                  |
|------------|----------|---------------------------------------------------|
|          1 | SIGHUP   | Hang up.                                          |
|          2 | SIGINT   | Interrupt.                                        |
|          3 | SIGQUIT  | Stop running.                                     |
|          9 | SIGKILL  | Unconditionally terminate.                        |
|         11 | SIGSEGV  | Segment violation.                                |
|         15 | SIGTERM  | Terminate if possible.                            |
|         17 | SIGSTOP  | Stop unconditionally, but don’t terminate.        |
|         18 | SIGTSTP  | Stop or pause, but continue to run in background. |
|         19 | SIGCONT  | Resume execution after STOP or TSTP.              |

By default, the bash shell ignores any SIGQUIT (3) and SIGTERM (15) signals that it receives (this is so that an interactive shell can’t be accidentally terminated). However, the bash shell processes any SIGHUP (1) and SIGINT (2) signals it receives.

If the bash shell receives a SIGHUP signal, it exits. Before it exits though, it passes the SIGHUP signal to any processes started by the shell (such as your shell script). With a SIGINT signal, the shell is just interrupted. The Linux kernel stops giving the shell processing time on the CPU. When this happens, the shell passes the SIGINT signal to any processes started by the shell to notify them of the situation.


### Generating signals <a id="HS-GS">[≡](#≡)</a>

The bash shell allows you to generate two basic Linux signals using key combinations on the keyboard. This feature comes in handy if you need to stop or pause runaway programs.

#### Interrupting a process <a id="HS-GS-IAP">[≡](#≡)</a>

The `Ctrl-C` key combination generates a SIGINT signal, and sends it to any processes currently running in the shell.


#### Pausing a process <a id="HS-GS-PAP">[≡](#≡)</a>

The `Ctrl-Z` key combination generates a SIGTSTP signal, stopping any processes running in the shell. Stopping a process is different than terminating the process, as stopping the process leaves the program still in memory, and able to continue running from where it left off. 

Sometimes this can be a dangerous thing (for example, if a script has a file lock open on a crucial system file)

When you use the Ctrl-Z key combination, the shell informs you that the process has been
stopped, for example:    
```
$ sleep 10
^Z
[1]+  Stopped                 sleep 10
```
The _number_ in the square brackets is the job number assigned by the shell.    
The shell refers to each process running in the shell as a job, and assigns each job a unique job number. It assigns the first process started job number 1, the second job number 2, and so on.

If you have a stopped job assigned to your shell session, bash will warn you if you try to exit the shell:    
```
$ exit
logout
There are stopped jobs.
```

You can view the stopped job by using our friend the ps command:    
```
$ ps au
USER        PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root        665  0.0  0.0 110036   832 tty1     Ss+  04:51   0:00 /sbin/agetty --noclear tty1 linux
root       2160  0.0  0.1 116040  2700 pts/0    Ss   04:51   0:00 -bash
root       2214  0.0  0.1 189760  2452 pts/0    S    04:53   0:00 su - setamv
setamv     2215  0.0  0.1 116176  3012 pts/0    S    04:53   0:00 -bash
setamv     2409  0.0  0.0 107896   604 pts/0    T    05:30   0:00 sleep 10
setamv     2416  0.0  0.0 151056  1820 pts/0    R+   05:36   0:00 ps au
```
The ps command shows the status of the stopped job as T, which indicates the command is either being traced or is stopped.

If you really want to exit the shell with the stopped job still active, just type the exit command again. The shell will exit, terminating the stopped job. You can also use the `kill` command to send a SIGKILL signal to terminate it:
```
$ kill -9 2409
$ echo $?
0
[1]+  Killed                  sleep 10
```
When you kill the job, initially you won’t get any response. However, the next time you do something that produces a shell prompt, you’ll see a message indicating that the job was killed, like the script above.


### Trapping signals <a id="HS-TS">[≡](#≡)</a>

The `trap` command allows you to specify which Linux signals your shell script can watch for and intercept from the shell. If the script receives a signal listed in the `trap` command, it prevents it from being processed by the shell, and instead handles it locally.

The format of the trap command is:   
`trap commands signals`

On the trap command line, you just list the commands you want the shell to execute, along with a space-separated list of signals you want to trap. You can specify the signals either by their numeric value or by their Linux signal name.    

Here’s a simple example of using the trap command to ignore SIGINT and SIGTERM signals:  
```
#!/bin/bash

$ cat trapsig.sh 
#!/bin/bash
trap "echo 'signal received and i just want to ignore them, Hahaha!'" SIGINT SIGTERM
echo "Now the process will take a while for 3 seconds and do 2 times."
count=1
while ((count <= 2))
do
   echo "Loop $count and going to sleep 3 seconds."  
   sleep 3
   ((count = count + 1))
done
echo "This is the end of process."

$ ./trapsig.sh 
Now the process will take a while for 3 seconds and do 4 times.
Loop 1 and going to sleep 3 seconds.
^Csignal received and i just want to ignore them, Hahaha!
Loop 2 and going to sleep 3 seconds.
This is the end of process.
```

When the `Ctrl-C` key combination was used, the script executed the echo statement specified in the `trap` command instead of ignoring the signal and allowing the shell to stop the script, the script still finished the left loop round after `Ctrl-C` is trapped. 


### Trapping a script exit <a id="HS-TASE">[≡](#≡)</a>

Besides trapping signals in your shell script, you can trap them when the shell script exits. This is a convenient way to perform commands just as the shell finishes its job. To trap the shell script exiting, just add the EXIT signal to the trap command:   
```
#!/bin/bash

$ cat trapsig.sh 
#!/bin/bash
trap "echo byebye" EXIT
echo "Now the process will take a while for 3 seconds and do 2 times."
count=1
while ((count <= 2))
do
   echo "Loop $count and going to sleep 3 seconds."  
   sleep 3
   ((count = count + 1))
done
echo "This is the end of process."

$ ./trapsig.sh 
Now the process will take a while for 3 seconds and do 4 times.
Loop 1 and going to sleep 3 seconds.
Loop 2 and going to sleep 3 seconds.
This is the end of process.
byebye

$ ./trapsig.sh 
Now the process will take a while for 3 seconds and do 4 times.
Loop 1 and going to sleep 3 seconds.
^Cbyebye
```

When the script gets to the normal exit point, the trap is triggered, and the shell executes the command you specify on the `trap` command line.

When the `Ctrl-C` key combination is used to send a SIGINT signal, the script exits (since that signal isn’t listed in the trap list), but before the script exits, the shell executes the `trap` command.


### Removing a trap <a id="HS-RAT">[≡](#≡)</a>

You can remove a set trap by using a dash between the `trap` command and a list of the signals you want to return to normal behavior:   
```
#!/bin/bash

$ cat trapsig.sh 
#!/bin/bash
trap "echo byebye" EXIT
echo "Now the process will take a while for 3 seconds and do 4 times."
count=1
while ((count <= 2))
do
   echo "Loop $count and going to sleep 3 seconds."  
   sleep 3
   ((count = count + 1))
done
trap - EXIT
echo "I just removed the EXIT trap"

$ ./trapsig.sh 
Now the process will take a while for 3 seconds and do 4 times.
Loop 1 and going to sleep 3 seconds.
^Cbyebye

$ ./trapsig.sh 
Now the process will take a while for 3 seconds and do 4 times.
Loop 1 and going to sleep 3 seconds.
Loop 2 and going to sleep 3 seconds.
I just removed the EXIT trap
```


## Running Scripts in Background Mode <a id="RSIBM">[≡](#≡)</a>

In background mode, a process runs without being associated with a STDIN, STDOUT, and STDERR on a terminal session.

### Running in the background <a id="RSIBM-RITB">[≡](#≡)</a>

To run a shell script in background mode from the command line interface, just place an ampersand symbol after the command:           
```
#!/bin/bash

$ cat background.sh 
#!/bin/bash
exec 1> debug.log
count=1
while ((count <= 3))
do
   echo "The $count loop, going to sleep 3 seconds."
   sleep 3
   ((count = count + 1))
done
echo "The end of process."

$ ./background.sh &
[1] 2576

$ cat debug.log
The 1 loop, going to sleep 3 seconds.
The 2 loop, going to sleep 3 seconds.
The 3 loop, going to sleep 3 seconds.
The end of process.
[1]+  Done                    ./background.sh
```
When you place the ampersand symbol after a command it runs as a separate background process on the system. The first thing that displays is the line:  
`[1] 2535`
The number in the square brackets is the job number assigned to the background process by the shell. The next number is the PID the Linux system assigns to the process.

After display the job number and PID, a new command line interface prompt immediately appears. You are returned back to the shell, and the command you executed runs safely in background mode. 

When the background process finishes, it displays a message on the terminal:    
`[1]+  Done                    ./background.sh`
This shows the job number and the status of the job (Done), along with the command used to start the job.

### Exiting the terminal <a id="RSIBM-ETT">[≡](#≡)</a>

You must be careful when using background processes from a terminal session. Notice in the output from the ps command that each of the background processes is tied to the terminal session (pts/0) terminal:   
```
$ ./background.sh &
$ ps au
USER        PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
setamv     2215  0.0  0.1 116176  3020 pts/0    S    04:53   0:00 -bash
setamv     2637  0.3  0.0 113124  1384 pts/0    S    06:58   0:00 /bin/bash ./background.sh
setamv     2639  0.0  0.0 107896   604 pts/0    S    06:58   0:00 sleep 3
setamv     2640  0.0  0.0 151056  1824 pts/0    R+   06:58   0:00 ps au
```
If the terminal session exits, the background process also exits.

## Running Scripts without a Console <a id="RSWAC">[≡](#≡)</a>

When you want to start a shell script from a terminal session, then let the script run in background mode until it finishes, even if you exit the terminal session. You can do
this by using the `nohup` command.

The `nohup` command runs another command blocking any SIGHUP signals that are sent to the
process. This prevents the process from exiting when you exit your terminal session.

The format used for the nohup command is:  
```
#!/bin/bash

$ cat background.sh 
#!/bin/bash
count=1
while ((count <= 3))
do
   echo "The $count loop, going to sleep 3 seconds."
   sleep 3
   ((count = count + 1))
done
echo "The end of process."

$ nohup ./background.sh &
nohup: ignoring input and appending output to ‘nohup.out’
$ cat nohup.out
The 1 loop, going to sleep 3 seconds.
The 2 loop, going to sleep 3 seconds.
The 3 loop, going to sleep 3 seconds.
```

Just as with a normal background process, the shell assigns the command a job number, and
the Linux system assigns a PID number. The difference is that when you use the `nohup` command, the script ignores any `SIGHUP` signals sent by the terminal session if you close the session, that means the background process started by `nohup` will not exit even when the shell which started the process exited, this is a main difference between normal background process(use `&` after command) and `nohup`.    

Because the nohup command disassociates the process from the terminal, the process loses the STDOUT and STDERR output links. To accommodate any output generated by the command,
the nohup command automatically redirects STDOUT and STDERR messages to a file, called
"nohup.out".

If you run another command using `nohup`, the output is appended to the existing nohup.out file. Be careful when running multiple commands from the same directory, as all of the output will be sent to the same nohup.out file.


## Job Control <a id="JC">[≡](#≡)</a>

The function of _starting_, _stopping_, _killing_, and _resuming_ jobs is called job control. With job control, you have full control over how processes run in your shell environment.

### Viewing jobs <a id="JC-VJ">[≡](#≡)</a>

The key command for job control is the `jobs` command. The `jobs` command allows you to
view the current jobs being handled by the shell:     
```
#!/bin/bash

$ cat background.sh 
#!/bin/bash
count=1
while ((count <= 3))
do
   echo "The $count loop, going to sleep 3 seconds."
   sleep 3
   ((count = count + 1))
done
echo "The end of process."

$ ./background.sh 
The 1 loop, going to sleep 3 seconds.
^Z
[1]+  Stopped                 ./background.sh

$ ./background.sh > debug.log &
[2] 2718

$ jobs
[1]+  Stopped                 ./background.sh
[2]-  Running                 ./background.sh > debug.log &
```
After the first job started, I used the `Ctrl-Z` key combination to stop the process.
The jobs command shows both the stopped and the running jobs, along with their job numbers and the commands used in the jobs.

The table bellow shows `jobs` command line parameters:  

| **Parameter** |                    **Description**                     |
|---------------|--------------------------------------------------------|
| -l            | List the PID of the process along with the job number. |
| -n            | List only jobs that have changed their status          |
|               | since the last notification from the shell.            |
| -p            | List only the PIDs of the jobs.                        |
| -r            | List only the running jobs.                            |
| -s            | List only stopped jobs.                                |


### Restarting stopped jobs <a id="JC-RSJ">[≡](#≡)</a>

Under bash job control, you can restart any stopped job as either a background process or a foreground process.

To restart a job in background mode, use the `bg` command, along with the job number:  
```
$ jobs
[1]-  Stopped                 ./background.sh
[2]+  Stopped                 ./background.sh

$ bg 2

$ jobs
[1]-  Stopped                 ./background.sh
[2]+  Running                 ./background.sh
```

To restart a job in foreground mode, use the `fg` command, along with the job number, Since the job is running in foreground mode, you won't get a new command line interface prompt until the jobs finishes.

## Being Nice <a id="BN">[≡](#≡)</a>

In a multitasking operating system (which Linux is), the kernel is responsible for assigning CPU time for each process running on the system. Only one process at a time can actually be running in the CPU, so the kernel assigns CPU time to each process in turn.

The scheduling priority is an integer value, from −20 (the highest priority) to +20 (the lowest priority). By default, the bash shell starts all processes with a priority of 0.

This means that a simple script that only requires a little bit of processing time gets the same CPU time slices as a complex mathematical algorithm that can take hours to run.

Sometimes you want to change the priority of a specific command, either lowering its priority so that it doesn’t take as much processing power from the CPU or giving it a higher priority so that it gets more processing time. You can do this by using the `nice` command.

### The nice command <a id="BN-TNC">[≡](#≡)</a>

The `nice` command allows you to set the scheduling priority of a command as you start it. To make a command run with less priority, just use the `-n num` command line option where the num is a positive integer:   
```
#!/bin/bash

$ cat nicedemo.sh 
#!/bin/bash
sleep 10

$ nice -n 10 ./nicedemo.sh &
[1] 2304

$ ps al
F   UID    PID   PPID PRI  NI    VSZ   RSS WCHAN  STAT TTY        TIME COMMAND
...
0  1000   2304   2235  30  10 113120  1172 wait   SN   pts/0      0:00 /bin/bash ./nicedemo.sh
0  1000   2305   2304  30  10 107896   608 hrtime SN   pts/0      0:00 sleep 10

$ ./nicedemo.sh &
[2] 2324

$ ps al
F   UID    PID   PPID PRI  NI    VSZ   RSS WCHAN  STAT TTY        TIME COMMAND
...
0  1000   2324   2235  20   0 113120  1176 wait   S    pts/0      0:00 /bin/bash ./nicedemo.sh
0  1000   2325   2324  20   0 107896   608 hrtime S    pts/0      0:00 sleep 10
```
The default nice value is 0.

The nice command causes the script to run at a lower priority. However, if you try to increase the priority of one of your commands by a normal system user(not root), you will get an error:   
```
$ nice -n -10 ./nicedemo.sh &
[3] 2330
[2]   Done                    ./nicedemo.sh
$ nice: cannot set niceness: Permission denied
```
The nice command prevents _normal_ system users from increasing the priority of their commands. This is a safety feature to prevent a user from starting all of his or her commands as high priority.  


### The renice command <a id="BN-TRC">[≡](#≡)</a>

Sometimes you’d like to change the priority of a command that’s already running on the system. That’s what the renice command is for. It allows you to specify the PID of a running process to change the priority of:    
```
$ renice 10 -p 29504
```

The renice command has some limitations:    

1. You can only renice processes that you own.
2. You can only renice your processes to a lower priority.
3. The root user can renice any process to any priority.


## Running Like Clockwork <a id="RLC">[≡](#≡)</a>

The Linux system provides three ways of running a script at a preselected time:   

1. The `at` command
2. The `batch` command
3. The `cron` table

Each method uses a different technique for scheduling when and how often to run scripts.

### Scheduling a job using the `at` command <a id="RLC-SAJUTAC">[≡](#≡)</a>

The `at` command allows you to specify a time when the Linux system will run a script. The `at` command submits a job to a queue with directions on when the shell should run the job. Another command, `atd`, runs in the background and checks the job queue for jobs to run. Most Linux distributions start this automatically at boot time.

The `atd` command checks a special directory on the system (usually /var/spool/at) for jobs submitted using the `at` command. By default the `atd` command checks this directory every 60 seconds. When a job is present, the `atd` command checks the time the job is set to be run. If the time matches the current time, the `atd` command runs the job.

#### The at command format <a id="RLC-SAJUTAC-TACF">[≡](#≡)</a>

The basic `at` command format is pretty simple:     
`at [-f filename] time`

By default, the at command submits input from STDIN to the queue. You can specify a filename used to read commands (your script file) using the -f parameter.

The following example is read command from STDIN:   
```
$ at 08:59
at> echo "hello"
at> <EOT>
job 12 at Sat Apr  8 08:59:00 2017
```
Where <EOT> is `Ctrl-D` key combination.


The time parameter specifies when you want the Linux system to run the job. You can get pretty creative with how you specify the time. The at command recognizes lots of different time formats:    

- A standard hour and minute, such as 10:15
- An AM/PM indicator, such as 10:15PM
- A specific named time, such as now, noon, midnight, or teatime (4PM)

If you specify a time that’s already past, the at command runs the job at that time on the next day.

Besides specifying the time to run the job, you can also include a specific date, using a few different date formats:

- A standard date format, such as MMDDYY, MM/DD/YY, or DD.MM.YY
- A text date, such as Jul 4 or Dec 25, with or without the year
- You can also specify a time increment:
    + Now + 25 minutes
    + 10:15PM tomorrow
    + 10:15 + 7 days

There are 26 different job queues available for different priority levels. Job queues are referenced using lower-case letters, a through z.    
By default all at jobs are submitted to job queue a, the highest-priority queue. If you want to run a job at a lower priority, you can specify the letter using the -q parameter.

#### Retrieving job output <a id="RLC-SAJUTAC-RJO">[≡](#≡)</a>

When the job runs on the Linux system, there’s no monitor associated with the job. Instead, the Linux system uses the e-mail address of the user who submitted the job as STDOUT and STDERR. Any output destined to STDOUT or STDERR is mailed to the user via the mail system.

Here’s a simple example of using the at command to schedule a job to run:   
```
#!/bin/bash

$ cat atdemo.sh 
#!/bin/bash
now=`date +%T`
echo "This script run at $now"
echo "This is the end of the script." >&2

$ at -f ./atdemo.sh 8:43
job 4 at Sat Apr  8 08:43:00 2017

$ mail 

```

在Red Hat上没有收到邮件，但是如果将结果重定向到文件，还是可以看到job是按时执行了。


#### Listing pending jobs <a id="RLC-SAJUTAC-LPJ">[≡](#≡)</a>

The `atq` command allows you to view what jobs are pending on the system:   
```
$ atq
15  Mon Apr 10 23:10:00 2017 a setamv
```


#### Removing jobs <a id="RLC-SAJUTAC-RJ">[≡](#≡)</a>

Once you know the information about what jobs are pending in the job queues, you can use the `atrm` command to remove a pending job, the format is:    
```
$ atrm jobnum
```
The _jobnum_ is the job number.


### Using the batch command <a id="RLC-UTBC">[≡](#≡)</a>

The `batch` command is a little different from the `at` command. Instead of scheduling a script to run at a preset time, you use the `batch` command to schedule a script to run when the system is at a lower usage level.

If the Linux system is experiencing high load levels, the batch command will defer running a submitted job until things quiet down. You can schedule a script to run during
the quiet time without having to know exactly when that is.

The batch command checks the current load average of the Linux system. If the load average is below 0.8, it runs any jobs waiting in the job queue.

The command format for the batch command is:    
```
batch [-f filename] [time]
```

Similarly to the at command, by default the batch command reads commands from STDIN. You
can use the -f parameter to specify a file to read commands from. You can also optionally specify the earliest time that the batch command should try running the job.


### Scheduling regular scripts <a id="RLC-SRS">[≡](#≡)</a>

Using the at command to schedule a script to run at a preset time is great, but what if you need that script to run at the same time every day or once a week or once a month? Instead of having to continually submit at jobs, you can use another feature of the Linux system.

The Linux system uses the `cron` program to allow you to schedule jobs that need to run on a regular basis. The `cron` program runs in the background and checks special tables, called _cron tables_, for jobs that are scheduled to run.

#### The cron table <a id="RLC-SRS-TCT">[≡](#≡)</a>

The _cron table_ uses a special format for allowing you to specify when a job should be run. The format for the cron table is:    

`min hour dayofmonth month dayofweek command`     

The cron table allows you to specify entries as specific values, ranges of values (such as 1–5) or as a wildcard character (the asterisk). 

Examples:

- `15 10 * * * command` 
    Run a command at 10:15 on every day, the wildcard character used in the _dayofmonth_, _month_, and _dayofweek_ fields indicates that `cron` will execute the command every day of every month at 10:15.

- `15 16 * * 1 command`
    Run a command at 4:15PM every Monday. You can specify the _dayofweek_ entry as either a three-character text value (mon, tue, wed, thu, fri, sat, sun) or as a numeric value, with 0 being Sunday and 6 being Saturday.

- `00 12 1 * * command`
    Run a command at 12 noon on the first day of every month. The _dayofmonth_ entry specifies a date value (1–31) for the month.

- How to speicify the last day of every month?
    A common method is to add an if-then statement that uses the date command to check if tomorrow’s date is 01:      
    ```
    00 12 * * * if [ `date +%d -d tomorrow` = 01 ] ; then ; command
    ```
    This will check every day at 12 noon to see if it’s the last day of the month, and if so, it will run the command.

The command list must specify the full pathname of the command or shell script to run. You can add any command line parameters or redirection symbols you like, as a regular command line:    
```
15 10 * * * /home/rich/test.sh > test4out
```

The `cron` program runs the script using the user account that submitted the job. Thus, you must have the proper permissions to access the command and output files specified in the command listing.


#### Building the cron table <a id="RLC-SRS-BTCT">[≡](#≡)</a>

Each system user can have their own cron table (including the root user) for running scheduled jobs. Linux provides the `crontab` command for handling the cron table. To list an existing cron table, use the -l parameter:    
```
$ crontab -l
no crontab for setamv
```

By default, each user’s _cron table_ file doesn’t exist. To add entries to your _cron table_, use the `-e` parameter. When you do that, the crontab command automatically starts the vi editor with the existing _cron table_ (or an empty file if it doesn’t yet exist).

##### The anacron program <a id="RLC-SRS-BTCT-TAP">[≡](#≡)</a>

If the Linux system is turned off at the time a job is scheduled to run by `cron`, the job won’t run. The `cron` program doesn’t retroactively run missed jobs when the system is turned back on. To resolve this issue, many Linux distributions also include the `anacron` program.

The `anacron` program uses timestamps to determine if a scheduled job has been run at the
proper interval. If it determines that a job has missed a scheduled running, it automatically runs the job as soon as possible. This means that if your Linux system is turned off for a few days, when it starts back up any jobs scheduled to run during the time it was off are automatically run.

The anacron program has its own table (usually located at /etc/anacrontab) to specify jobs. On almost all Linux distributions, this table is only accessible by the root user. The format of the anacron table is slightly different from that of the cron table:    
```
period delay identifier command
```

The _period_ entry defines how often the job should be run, specified in days. The _delay_ entry specifies how many minutes after the anacron program determines that a command should be run it should actually run it.

The _identifier_ entry is a unique non-blank character string to uniquely identify the job in log messages and error e-mails.



## Start At the Beginning <a id="SATB">[≡](#≡)</a>

The last method of starting shell scripts is to have your script run automatically either as soon as the Linux system boots or whenever a user starts a new bash shell session.

### Starting your scripts at boot <a id="SATB-SYSAB">[≡](#≡)</a>

#### The boot process <a id="SATB-SYSAB-TBP">[≡](#≡)</a>

The boot process after you turn on the linux system is:  

1. the Linux kernel loads into memory and runs
2. the Linux kernel run the `init` program
    The `init` program usually located at /sbin/init, Since the init program is always the first thing to run, the kernel always assigns it PID 1
3. The `init` program reads the /etc/inittab file as part of the boot process
    The inittab file lists scripts that the `init` program starts at different run levels, A Linux run level defines the operating state of the Linux system, the table bellow shows the avalible levels:   

    | **Run level** |                          **Description**                          |
    |---------------|-------------------------------------------------------------------|
    |             0 | Halt                                                              |
    |             1 | Single-user mode                                                  |
    |             2 | Multi-user mode, usually without networking support               |
    |             3 | Full multi-user mode, with networking                             |
    |             4 | Unused                                                            |
    |             5 | Multi-user mode, with networking and a graphical X Window session |
    |             6 | Reboot                                                            |

    The Linux system determines what programs to start at what run level by the `rc` script. The `rc` script determines the current system run level and runs the appropriate scripts for that run level.

    The Linux system starts applications using startup scripts. A startup script is a shell script that starts an application, providing the necessary environment variables for it to run.

4. Execute startup scripts
    Some distributions place startup scripts in the /etc/rc.d directory, with a different directory for each run level. Others use the /etc/init.d directory, and still others use the /etc/init.d/rc.d directory
    

#### Defining your scripts <a id="SATB-SYSAB-DYS">[≡](#≡)</a>

Most Linux distributions provide a local startup file specifically to allow the system
administrator to enter scripts to run at boot time, the table bellow list three popular Linux distributions' location of the startup file:  

| **Distribution** |   **File Location**    |
|------------------|------------------------|
| Debian           | /etc/init.d/rc.local   |
| Fedora           | /etc/rc.d/rc.local     |
| openSuse         | /etc/init.d/boot.local |

Inside the local startup file, you can either specify specific commands and statements, or enter any scripts you want started at boot time. Remember, if you use a script, you’ll need to specify the full pathname for the script so that the system can find it at boot time.


### Starting with a new shell <a id="SATB-SWNS">[≡](#≡)</a>

There are multiple start scripts while starts a new bash shell or login:   

1. The ~/.bash_profile file
    The bash shell runs the ~/.bash_profile file when a new shell is run as a result of a new login. Place any scripts that you want run at login time in this file.

2. The ~/.bashrc file
    The bash shell runs the .bashrc file any time a new shell is started, including when a new login occurs. You can test this by adding a simple echo statement to the .bashrc file in your home directory, then starting a new shell:
    ```
    $ bash
    This is a new shell!!
    ```

3. The /etc/bashrc file
    If you want to run a script for every user on the system, most Linux distributions provide the /etc/bashrc file. The bash shell executes the statements in this file every time any user on the system starts a new bash shell.

