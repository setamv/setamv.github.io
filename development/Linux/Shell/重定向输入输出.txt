【标准输入输出表】

序号	输入/输出		代码	符号		说明			
 1		标准输入 		0 		< 或 <<		<为覆盖，<<为追加
 2		标准输出 		1 		> 或 >>		> 覆盖式；>> 追加式。也可以写成 1>
 3 		标准错误输出	2		2> 或 2>> 	2> 覆盖式；2>> 追加式

注意：
	上面的标准输入符号前面不用写代码，是因为标准输入符号前默认就是0，也可以显示指定为 0< 或 0<<
 

【/dev/null垃圾桶黑洞】
	重定向到 /dev/null 中的数据都将默默的消失，既不会打印在屏幕上，也不会存储到某个文件目录。所以称为垃圾桶黑洞。


【标准输出示例】
$ find /home -name somefile > ~/find_right.re 2> ~/find_error.re
说明：
	非root用户使用find命令查找文件时，可能遇到permission denied错误，上面的示例将错误信息重定向输出到 ~/find_error.re中，正确的查找结果输出到 ~/find_right.re中。


【标准输出和标准错误输出重定向到相同的目标】

$ find /home -name somefile > ~/find.re 2> ~/find.re 	
这种写法存在一定的问题，由于两股数据同时写入一个文件，又没有使用特殊的语法，
此时两股数据可能会交叉写入该文件内，造成次序的错乱。并且这里标准输出和标准错误输出都是覆盖式的写入，有可能部分数据会丢失。

2、$ find /home -name somefile > ~/find.re 2>&1		
这种写法OK
也可以使用 >> ~/find.re 2>>&1 指定以追加的方式
当然，调个头也是可以的，如：$ find /home -name somefile 2> ~/error.re 1>&2

3、$ find /home -name somefile &> ~/find.re  	
这种写法也OK
也可以使用 &>> ~/find.re 指定以追加的方式


【标准输入示例】
$ cat > ~/somefile.bak < ~/somefile
说明：
上面的指令利用标准输入和输出实现了类似文件拷贝的功能，将文件 ~/somefile 拷贝到 ~/somefile.bak 中。



【将指令的执行结果赋值到变量】

下面是将一个指令的执行结果赋值给一个变量，即文件“somefile”的类型：

$ re=$(file somefile)

如果当赋值语句后面的指令执行失败，变量还能取得到失败的结果吗？

比如，先登录到一个普通的用户账号，尝试删除一个系统文件，如 /etc/passwd 文件，然后将执行结果赋值给一个变量：

$ re=$(rm -f /etc/passwd)

上面的删除命令肯定会执行失败，所以此时执行结果会输出到“标准错误输出中”，而赋值是取得“标准输出”内容，所以，上面的变量re并不能取得错误提示信息。相反，该错误信息会被打印到屏幕。
如果要让该错误信息保存到变量re该怎么办呢？只要将“标准错误输出”重定向到“标准输出”即可，如下面所示：
$ re=$(rm -f /etc/passwd 2>&1)
此时，不管是执行正确还是错误，结果都会保存到变量re中。